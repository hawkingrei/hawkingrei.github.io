<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Linux系统编程笔记：Linux中的fork - Hawkingrei</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="Linux系统编程笔记：Linux中的fork">
<meta itemprop="description" content="“fork是一种创建自身进程副本的操作。 ”
 Background 最近正在阅读Twemproxy的源代码，从中发现涉及到大量《操作系统原理》和Linux系统编程的知识，由此我这些知识记录下来，做一个系列的笔记。
概论 在多任务操作系统中，运行中的程序需要一种方法来创建新进程，例如运行其他程序。Fork及其变种在类Unix系统中通常是这样做的唯一方式。如果进程需要启动另一个程序的可执行文件，它需要先Fork来创建一个自身的副本。然后由该副本即“子进程”调用exec系统调用，用其他程序覆盖自身：停止执行自己之前的程序并执行其他程序。
正文 进程复制 Fork操作会为子进程创建一个单独的定址空间。子进程拥有父进程所有内存段的精确副本，其中包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。
当一个进程调用fork时，它被认为是父进程，新创建的进程是它的孩子（子进程）。在fork之后，两个进程还运行着相同的程序，都像是调用了该系统调用一般恢复执行。然后它们可以检查调用的返回值确定其状态：是父进程还是子进程，以及据此行事。
子进程与父进程的区别在于：
  父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）。
  各自的进程ID和父进程ID不同,且与存在的进程PID都不同。
  子进程的未决告警被清除。
  子进程的未决信号集设置为空集。
  子进程不会从父进程继承dnotify(directory change notifications)。
  在子进程中的 resource utilizations (getrusage)和CPU time counters (times)会被归零。
  子进程不能从父进程继承计时器(setitimer, alarm, timer_create)。
  子进程不能从父进程继承异步I/0操作（aio_write,aio_read）,也不能从父进程继承asynchronous I/O contexts.(io_setup)。
  上面列出是在POSIX.1-2001下的不同点,下面是linux系统特用的不通点。
  子进程不能继承由ioperm设置的I/O 端口访问权限，子进程必须使用ioperm来开启端口访问权限。
  子进程的中断信号是SIGCHLD（clone）。
  Memory mappings 是被madvise设置的话，MADV_DONTFORK标识不会继承给子进程的
  默认的timer slack值由父进程中的当前timer slack值来设置。 （可以看一下prctl中的PR_SET_TIMERSLACK的描述）"><meta itemprop="datePublished" content="2017-08-08T10:00:00+00:00" />
<meta itemprop="dateModified" content="2017-08-08T10:00:00+00:00" />
<meta itemprop="wordCount" content="176">
<meta itemprop="keywords" content="Linux,C,note," /><meta property="og:title" content="Linux系统编程笔记：Linux中的fork" />
<meta property="og:description" content="“fork是一种创建自身进程副本的操作。 ”
 Background 最近正在阅读Twemproxy的源代码，从中发现涉及到大量《操作系统原理》和Linux系统编程的知识，由此我这些知识记录下来，做一个系列的笔记。
概论 在多任务操作系统中，运行中的程序需要一种方法来创建新进程，例如运行其他程序。Fork及其变种在类Unix系统中通常是这样做的唯一方式。如果进程需要启动另一个程序的可执行文件，它需要先Fork来创建一个自身的副本。然后由该副本即“子进程”调用exec系统调用，用其他程序覆盖自身：停止执行自己之前的程序并执行其他程序。
正文 进程复制 Fork操作会为子进程创建一个单独的定址空间。子进程拥有父进程所有内存段的精确副本，其中包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。
当一个进程调用fork时，它被认为是父进程，新创建的进程是它的孩子（子进程）。在fork之后，两个进程还运行着相同的程序，都像是调用了该系统调用一般恢复执行。然后它们可以检查调用的返回值确定其状态：是父进程还是子进程，以及据此行事。
子进程与父进程的区别在于：
  父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）。
  各自的进程ID和父进程ID不同,且与存在的进程PID都不同。
  子进程的未决告警被清除。
  子进程的未决信号集设置为空集。
  子进程不会从父进程继承dnotify(directory change notifications)。
  在子进程中的 resource utilizations (getrusage)和CPU time counters (times)会被归零。
  子进程不能从父进程继承计时器(setitimer, alarm, timer_create)。
  子进程不能从父进程继承异步I/0操作（aio_write,aio_read）,也不能从父进程继承asynchronous I/O contexts.(io_setup)。
  上面列出是在POSIX.1-2001下的不同点,下面是linux系统特用的不通点。
  子进程不能继承由ioperm设置的I/O 端口访问权限，子进程必须使用ioperm来开启端口访问权限。
  子进程的中断信号是SIGCHLD（clone）。
  Memory mappings 是被madvise设置的话，MADV_DONTFORK标识不会继承给子进程的
  默认的timer slack值由父进程中的当前timer slack值来设置。 （可以看一下prctl中的PR_SET_TIMERSLACK的描述）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://hawkingrei.com/posts/articles/linux_fork/2017-08-07-linux-fork/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-08T10:00:00+00:00" />
<meta property="article:modified_time" content="2017-08-08T10:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Linux系统编程笔记：Linux中的fork"/>
<meta name="twitter:description" content="“fork是一种创建自身进程副本的操作。 ”
 Background 最近正在阅读Twemproxy的源代码，从中发现涉及到大量《操作系统原理》和Linux系统编程的知识，由此我这些知识记录下来，做一个系列的笔记。
概论 在多任务操作系统中，运行中的程序需要一种方法来创建新进程，例如运行其他程序。Fork及其变种在类Unix系统中通常是这样做的唯一方式。如果进程需要启动另一个程序的可执行文件，它需要先Fork来创建一个自身的副本。然后由该副本即“子进程”调用exec系统调用，用其他程序覆盖自身：停止执行自己之前的程序并执行其他程序。
正文 进程复制 Fork操作会为子进程创建一个单独的定址空间。子进程拥有父进程所有内存段的精确副本，其中包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。
当一个进程调用fork时，它被认为是父进程，新创建的进程是它的孩子（子进程）。在fork之后，两个进程还运行着相同的程序，都像是调用了该系统调用一般恢复执行。然后它们可以检查调用的返回值确定其状态：是父进程还是子进程，以及据此行事。
子进程与父进程的区别在于：
  父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）。
  各自的进程ID和父进程ID不同,且与存在的进程PID都不同。
  子进程的未决告警被清除。
  子进程的未决信号集设置为空集。
  子进程不会从父进程继承dnotify(directory change notifications)。
  在子进程中的 resource utilizations (getrusage)和CPU time counters (times)会被归零。
  子进程不能从父进程继承计时器(setitimer, alarm, timer_create)。
  子进程不能从父进程继承异步I/0操作（aio_write,aio_read）,也不能从父进程继承asynchronous I/O contexts.(io_setup)。
  上面列出是在POSIX.1-2001下的不同点,下面是linux系统特用的不通点。
  子进程不能继承由ioperm设置的I/O 端口访问权限，子进程必须使用ioperm来开启端口访问权限。
  子进程的中断信号是SIGCHLD（clone）。
  Memory mappings 是被madvise设置的话，MADV_DONTFORK标识不会继承给子进程的
  默认的timer slack值由父进程中的当前timer slack值来设置。 （可以看一下prctl中的PR_SET_TIMERSLACK的描述）"/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="http://hawkingrei.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="http://hawkingrei.com/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="http://hawkingrei.com/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="http://hawkingrei.com/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="http://hawkingrei.com/">
				<img src="https://avatars.githubusercontent.com/u/3427324" alt="Hawkingrei" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="http://hawkingrei.com/">Hawkingrei</a></h1>
	<div class="site-description"><p>一生想做浪漫极客</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/hawkingrei" title="GitHub"><i data-feather="github"></i></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">08</span>
							<span class="rest">Aug 2017</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">Linux系统编程笔记：Linux中的fork</h1>
				</div>
			</div>
					
			<div class="markdown">
				<blockquote>
<p>“fork是一种创建自身进程副本的操作。 ”</p>
</blockquote>
<h2 id="background">Background</h2>
<p>最近正在阅读<a href="https://github.com/twitter/twemproxy">Twemproxy</a>的源代码，从中发现涉及到大量《操作系统原理》和Linux系统编程的知识，由此我这些知识记录下来，做一个系列的笔记。</p>
<h2 id="概论">概论</h2>
<p>在多任务操作系统中，运行中的程序需要一种方法来创建新进程，例如运行其他程序。Fork及其变种在类Unix系统中通常是这样做的唯一方式。如果进程需要启动另一个程序的可执行文件，它需要先Fork来创建一个自身的副本。然后由该副本即“子进程”调用exec系统调用，用其他程序覆盖自身：停止执行自己之前的程序并执行其他程序。</p>
<h2 id="正文">正文</h2>
<h3 id="进程复制">进程复制</h3>
<p>Fork操作会为子进程创建一个单独的定址空间。子进程拥有父进程所有内存段的精确副本，其中包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。</p>
<p>当一个进程调用fork时，它被认为是父进程，新创建的进程是它的孩子（子进程）。在fork之后，两个进程还运行着相同的程序，都像是调用了该系统调用一般恢复执行。然后它们可以检查调用的返回值确定其状态：是父进程还是子进程，以及据此行事。</p>
<p>子进程与父进程的区别在于：</p>
<ul>
<li>
<p>父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）。</p>
</li>
<li>
<p>各自的进程ID和父进程ID不同,且与存在的进程PID都不同。</p>
</li>
<li>
<p>子进程的未决告警被清除。</p>
</li>
<li>
<p>子进程的未决信号集设置为空集。</p>
</li>
<li>
<p>子进程不会从父进程继承<code>dnotify</code>(directory change notifications)。</p>
</li>
<li>
<p>在子进程中的 resource utilizations (<code>getrusage</code>)和CPU time counters (<code>times</code>)会被归零。</p>
</li>
<li>
<p>子进程不能从父进程继承计时器(<code>setitimer</code>, <code>alarm</code>, <code>timer_create</code>)。</p>
</li>
<li>
<p>子进程不能从父进程继承异步I/0操作（<code>aio_write</code>,<code>aio_read</code>）,也不能从父进程继承asynchronous I/O contexts.(<code>io_setup</code>)。</p>
</li>
</ul>
<p>上面列出是在POSIX.1-2001下的不同点,下面是linux系统特用的不通点。</p>
<ul>
<li>
<p>子进程不能继承由<code>ioperm</code>设置的I/O 端口访问权限，子进程必须使用<code>ioperm</code>来开启端口访问权限。</p>
</li>
<li>
<p>子进程的中断信号是<code>SIGCHLD</code>（<code>clone</code>）。</p>
</li>
<li>
<p>Memory mappings 是被<code>madvise</code>设置的话，MADV_DONTFORK标识不会继承给子进程的</p>
</li>
<li>
<p>默认的timer slack值由父进程中的当前timer slack值来设置。
（可以看一下<code>prctl</code>中的PR_SET_TIMERSLACK的描述）</p>
</li>
<li>
<p>prctl的PRSETPDEATHSIG设置会被重置，因此当父进程终止后，子进程不会收到信号。</p>
</li>
</ul>
<p>注意以下几点:</p>
<ul>
<li>
<p>子进程只包含一个线程，并且有fork产生。父进程的整个虚拟地址空间被复制给子进程，包括互斥器、条件变量和其他的pthread对象；这种行为带来的问题pthread_atfork可能有帮助。</p>
</li>
<li>
<p>子进程继承了父进程打开文件描述符。父进程和子进程指向相同的文件描述符。也就是说，两个进程的文件描述符共享相同的打开文件状态标志、当前文件偏移和信号驱动IO属性。</p>
</li>
<li>
<p>子进程继承了父进程打开消息队列描述符。父进程和子进程指向相同的消息队列描述符。也就是说，两个描述符共享相同的标志。</p>
</li>
<li>
<p>子进程继承了父进程打开目录流的集合。POSIX.1-2001说父子进程中的目录流可能共享目录流位置，但Linux/glibc没这么做。</p>
</li>
</ul>
<h3 id="实践">实践</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;stdio.h&gt;</span><span style="color:#00f">
</span></span></span><span style="display:flex;"><span><span style="color:#00f">#include</span> <span style="color:#00f">&lt;unistd.h&gt;</span><span style="color:#00f">
</span></span></span><span style="display:flex;"><span><span style="color:#00f"></span>
</span></span><span style="display:flex;"><span><span style="color:#2b91af">int</span> main(<span style="color:#2b91af">int</span> argc, <span style="color:#2b91af">char</span> **argv)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    printf(<span style="color:#a31515">&#34;--beginning of program</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">int</span> counter = 0;
</span></span><span style="display:flex;"><span>    pid_t pid = fork();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">if</span> (pid == 0)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// child process
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#2b91af">int</span> i = 0;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (; i &lt; 5; ++i)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#a31515">&#34;child process: counter=%d</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>, ++counter);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span> <span style="color:#00f">if</span> (pid &gt; 0)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// parent process
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        <span style="color:#2b91af">int</span> j = 0;
</span></span><span style="display:flex;"><span>        <span style="color:#00f">for</span> (; j &lt; 5; ++j)
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            printf(<span style="color:#a31515">&#34;parent process: counter=%d</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>, ++counter);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#00f">else</span>
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#008000">// fork failed
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>        printf(<span style="color:#a31515">&#34;fork() failed!</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#00f">return</span> 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    printf(<span style="color:#a31515">&#34;--end of program--</span><span style="color:#a31515">\n</span><span style="color:#a31515">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>运行结果</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>--beginning of program
</span></span><span style="display:flex;"><span>parent process: counter=1
</span></span><span style="display:flex;"><span>parent process: counter=2
</span></span><span style="display:flex;"><span>parent process: counter=3
</span></span><span style="display:flex;"><span>parent process: counter=4
</span></span><span style="display:flex;"><span>parent process: counter=5
</span></span><span style="display:flex;"><span>child process: counter=1
</span></span><span style="display:flex;"><span>--end of program--
</span></span><span style="display:flex;"><span>child process: counter=2
</span></span><span style="display:flex;"><span>child process: counter=3
</span></span><span style="display:flex;"><span>child process: counter=4
</span></span><span style="display:flex;"><span>child process: counter=5
</span></span><span style="display:flex;"><span>--end of program--
</span></span></code></pre></div>
			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/linux">Linux</a></li>
							
							<li><a href="/tags/c">C</a></li>
							
							<li><a href="/tags/note">note</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2022  © Hawkingrei |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>

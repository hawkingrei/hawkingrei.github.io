<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>LevelDB代码阅读：Arena - Hawkingrei</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta itemprop="name" content="LevelDB代码阅读：Arena">
<meta itemprop="description" content="Arena源代码分析 首先我们来看定义
class Arena {  public:  Arena();  ~Arena();   // Return a pointer to a newly allocated memory block of &#34;bytes&#34; bytes.  char* Allocate(size_t bytes);   // Allocate memory with the normal alignment guarantees provided by malloc  char* AllocateAligned(size_t bytes);   // Returns an estimate of the total memory usage of data allocated  // by the arena.  size_t MemoryUsage() const {  return reinterpret_cast&lt;uintptr_t&gt;(memory_usage_."><meta itemprop="datePublished" content="2017-12-09T14:00:00+00:00" />
<meta itemprop="dateModified" content="2017-12-09T14:00:00+00:00" />
<meta itemprop="wordCount" content="422">
<meta itemprop="keywords" content="LevelDB," /><meta property="og:title" content="LevelDB代码阅读：Arena" />
<meta property="og:description" content="Arena源代码分析 首先我们来看定义
class Arena {  public:  Arena();  ~Arena();   // Return a pointer to a newly allocated memory block of &#34;bytes&#34; bytes.  char* Allocate(size_t bytes);   // Allocate memory with the normal alignment guarantees provided by malloc  char* AllocateAligned(size_t bytes);   // Returns an estimate of the total memory usage of data allocated  // by the arena.  size_t MemoryUsage() const {  return reinterpret_cast&lt;uintptr_t&gt;(memory_usage_." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://hawkingrei.com/posts/articles/area_in_leveldb/2017-12-09-arena-in-leveldb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-09T14:00:00+00:00" />
<meta property="article:modified_time" content="2017-12-09T14:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="LevelDB代码阅读：Arena"/>
<meta name="twitter:description" content="Arena源代码分析 首先我们来看定义
class Arena {  public:  Arena();  ~Arena();   // Return a pointer to a newly allocated memory block of &#34;bytes&#34; bytes.  char* Allocate(size_t bytes);   // Allocate memory with the normal alignment guarantees provided by malloc  char* AllocateAligned(size_t bytes);   // Returns an estimate of the total memory usage of data allocated  // by the arena.  size_t MemoryUsage() const {  return reinterpret_cast&lt;uintptr_t&gt;(memory_usage_."/>
<link href='https://fonts.googleapis.com/css?family=Playfair+Display:700' rel='stylesheet' type='text/css'>
	<link rel="stylesheet" type="text/css" media="screen" href="http://hawkingrei.com/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="http://hawkingrei.com/css/main.css" />

        <link id="dark-scheme" rel="stylesheet" type="text/css" href="http://hawkingrei.com/css/dark.css" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
		<script src="http://hawkingrei.com/js/main.js"></script>
</head>

<body>
	<div class="container wrapper">
		<div class="header">
	
		<div class="avatar">
			<a href="http://hawkingrei.com/">
				<img src="https://avatars.githubusercontent.com/u/3427324" alt="Hawkingrei" />
			</a>
		</div>
	
	<h1 class="site-title"><a href="http://hawkingrei.com/">Hawkingrei</a></h1>
	<div class="site-description"><p>一生想做浪漫极客</p><nav class="nav social">
			<ul class="flat"><li><a href="https://github.com/hawkingrei" title="GitHub"><i data-feather="github"></i></a></li></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
		</ul>
	</nav>
</div>


		<div class="post">
			<div class="post-header">
				
					<div class="meta">
						<div class="date">
							<span class="day">09</span>
							<span class="rest">Dec 2017</span>
						</div>
					</div>
				
				<div class="matter">
					<h1 class="title">LevelDB代码阅读：Arena</h1>
				</div>
			</div>
					
			<div class="markdown">
				<h2 id="arena源代码分析">Arena源代码分析</h2>
<p>首先我们来看定义</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#00f">class</span> <span style="color:#2b91af">Arena</span> {
</span></span><span style="display:flex;"><span> <span style="color:#00f">public</span>:
</span></span><span style="display:flex;"><span>  Arena();
</span></span><span style="display:flex;"><span>  ~Arena();  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#008000">// Return a pointer to a newly allocated memory block of &#34;bytes&#34; bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  <span style="color:#2b91af">char</span>* Allocate(size_t bytes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#008000">// Allocate memory with the normal alignment guarantees provided by malloc
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  <span style="color:#2b91af">char</span>* AllocateAligned(size_t bytes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#008000">// Returns an estimate of the total memory usage of data allocated
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  <span style="color:#008000">// by the arena.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  size_t MemoryUsage() <span style="color:#00f">const</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#00f">reinterpret_cast</span>&lt;uintptr_t&gt;(memory_usage_.NoBarrier_Load());
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#00f">private</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#2b91af">char</span>* AllocateFallback(size_t bytes);
</span></span><span style="display:flex;"><span>  <span style="color:#2b91af">char</span>* AllocateNewBlock(size_t block_bytes);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#008000">// Allocation state
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  <span style="color:#2b91af">char</span>* alloc_ptr_;
</span></span><span style="display:flex;"><span>  size_t alloc_bytes_remaining_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#008000">// Array of new[] allocated memory blocks
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  std::vector&lt;<span style="color:#2b91af">char</span>*&gt; blocks_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#008000">// Total memory usage of the arena.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  port::AtomicPointer memory_usage_;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#008000">// No copying allowed
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  Arena(<span style="color:#00f">const</span> Arena&amp;);
</span></span><span style="display:flex;"><span>  <span style="color:#2b91af">void</span> <span style="color:#00f">operator</span>=(<span style="color:#00f">const</span> Arena&amp;);
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>从定义来看，除了构造函数和析构函数，用户只需要调用<code>Allocate</code>、<code>AllocateAligned</code>和<code>MemoryUsage</code>就可以完成内存的调用。</p>
<p>其中MemoryUsage的定义如下，</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>  size_t MemoryUsage() <span style="color:#00f">const</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> <span style="color:#00f">reinterpret_cast</span>&lt;uintptr_t&gt;(memory_usage_.NoBarrier_Load());
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></div><p>MemoryUsage直接读取私有的memory_usage，转换成uintptr_t类型。</p>
<p>NoBarrier_Load方法是Leveldb的AtomicPointer实现，其位置在Leveldb的port目录下，是专门处理Leveldb跨平台特性的。之后会来介绍。<code>Alllocate</code>的实现如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#00f">inline</span> <span style="color:#2b91af">char</span>* Arena::Allocate(size_t bytes) {
</span></span><span style="display:flex;"><span>  <span style="color:#008000">// The semantics of what to return are a bit messy if we allow
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  <span style="color:#008000">// 0-byte allocations, so we disallow them here (we don&#39;t need
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  <span style="color:#008000">// them for our internal use).
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  assert(bytes &gt; 0);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (bytes &lt;= alloc_bytes_remaining_) {
</span></span><span style="display:flex;"><span>    <span style="color:#2b91af">char</span>* result = alloc_ptr_;
</span></span><span style="display:flex;"><span>    alloc_ptr_ += bytes;
</span></span><span style="display:flex;"><span>    alloc_bytes_remaining_ -= bytes;
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> result;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> AllocateFallback(bytes);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先检查输入的<code>bytes</code>是否大于0，然后申请内存大小<code>bytes</code>是否小于剩余预先分配的内存，如果小于，则移动<code>alloc_ptr_</code>指针，修改剩余内存大小，否则使用AllocateFallback向系统申请内存。</p>
<p>下面来一下AllocateFallback的实现</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#2b91af">char</span>* Arena::AllocateFallback(size_t bytes) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (bytes &gt; kBlockSize / 4) {
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// Object is more than a quarter of our block size.  Allocate it separately
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#008000">// to avoid wasting too much space in leftover bytes.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    <span style="color:#2b91af">char</span>* result = AllocateNewBlock(bytes);
</span></span><span style="display:flex;"><span>    <span style="color:#00f">return</span> result;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#008000">// We waste the remaining space in the current block.
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  alloc_ptr_ = AllocateNewBlock(kBlockSize);
</span></span><span style="display:flex;"><span>  alloc_bytes_remaining_ = kBlockSize;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  <span style="color:#2b91af">char</span>* result = alloc_ptr_;
</span></span><span style="display:flex;"><span>  alloc_ptr_ += bytes;
</span></span><span style="display:flex;"><span>  alloc_bytes_remaining_ -= bytes;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>AllocateFallback有两种分配内存的方案，通过判断<code>bytes &gt; kBlockSize / 4</code>，如果为真，直接按参数的大小来分配内存，否则按照<code>kBlockSize</code>的大小<code>4096</code>来分配，令<code>alloc_ptr</code>指向新分配的区域，但是其被分配的未使用内存则被浪费了。</p>
<p>接着我们来看一下AllocateAligned函数，其作用是分配内存，保证其内存对齐。AllocateAligned函数的定义如下</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#2b91af">char</span>* Arena::AllocateAligned(size_t bytes) {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">const</span> <span style="color:#2b91af">int</span> align = (<span style="color:#00f">sizeof</span>(<span style="color:#2b91af">void</span>*) &gt; 8) ? <span style="color:#00f">sizeof</span>(<span style="color:#2b91af">void</span>*) : 8;
</span></span><span style="display:flex;"><span>  assert((align &amp; (align-1)) == 0);   <span style="color:#008000">// Pointer size should be a power of 2
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  size_t current_mod = <span style="color:#00f">reinterpret_cast</span>&lt;uintptr_t&gt;(alloc_ptr_) &amp; (align-1);
</span></span><span style="display:flex;"><span>  size_t slop = (current_mod == 0 ? 0 : align - current_mod);
</span></span><span style="display:flex;"><span>  size_t needed = bytes + slop;
</span></span><span style="display:flex;"><span>  <span style="color:#2b91af">char</span>* result;
</span></span><span style="display:flex;"><span>  <span style="color:#00f">if</span> (needed &lt;= alloc_bytes_remaining_) {
</span></span><span style="display:flex;"><span>    result = alloc_ptr_ + slop;
</span></span><span style="display:flex;"><span>    alloc_ptr_ += needed;
</span></span><span style="display:flex;"><span>    alloc_bytes_remaining_ -= needed;
</span></span><span style="display:flex;"><span>  } <span style="color:#00f">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#008000">// AllocateFallback always returned aligned memory
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>    result = AllocateFallback(bytes);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  assert((<span style="color:#00f">reinterpret_cast</span>&lt;uintptr_t&gt;(result) &amp; (align-1)) == 0);
</span></span><span style="display:flex;"><span>  <span style="color:#00f">return</span> result;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>首先通过<code>(sizeof(void*) &gt; 8) ? sizeof(void*) : 8</code>获取<code>align</code>，在32位系统下是4，在64位系统下是8，
然后我们通过<code>reinterpret_cast&lt;uintptr_t&gt;(alloc_ptr_) &amp; (align-1)</code>，取当前指针模<code>align-1</code>的值，这样我们就可以知道需要补充的内存量， 所有有 slop = align - current_mod, 因此也就有了 needed = bytes + slop 和 result = alloc_ptr + slop。之后的流程就和<code>Allocate</code>函数如出一辙了，不再赘述。</p>
<p>最后就是Arena的析构函数和构造函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Arena::Arena() : memory_usage_(0) {
</span></span><span style="display:flex;"><span>  alloc_ptr_ = NULL;  <span style="color:#008000">// First allocation will allocate a block
</span></span></span><span style="display:flex;"><span><span style="color:#008000"></span>  alloc_bytes_remaining_ = 0;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>Arena::~Arena() {
</span></span><span style="display:flex;"><span>  <span style="color:#00f">for</span> (size_t i = 0; i &lt; blocks_.size(); i++) {
</span></span><span style="display:flex;"><span>    <span style="color:#00f">delete</span>[] blocks_[i];
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里需要注意<code>Arena::Arena() : memory_usage_(0)</code>的作用，其作用是来初始化列表相当于在构造函数内进行相应成员变量的赋值，但两者是有差别的。在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两者的差别在对于const类型数据的操作上表现得尤为明显。const类型的变量必须在定义时进行初始化，而不能对const型的变量进行赋值，因此const类型的成员变量只能（而且必须）在初始化列表中进行初始化。</p>
<h2 id="rocksdb的arena">Rocksdb的Arena</h2>
<p>Rocksdb是Leveldb的魔改升级版，相比leveldb，rocksdb对内存块的分配主要做了两点改进：一是抽象出内存分配Allocator，支持对不同内存管理策略进行定制扩展；二是启用HugePage支持，提高大内存机器下内存分配和访问的性能。这会在之后的文章中来专门介绍。</p>
<h2 id="收获">收获</h2>
<p>通过看leveldb的Arena实现，了解了memory pool的实现，随便复习了一下c++和CSAPP，看来之后还是要好好做一下CSAPP中Allocator的作业。在写这篇文章的过程中，挖了两个坑<em><strong>Leveldb的AtomicPointer实现</strong></em> 和 <em><strong>Rocksdb的Arena介绍</strong></em>，希望可以尽快填坑=。=</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="http://mingxinglai.com/cn/2013/01/leveldb-arena/">LevelDB源码剖析之Arena内存管理</a></li>
<li><a href="https://csruiliu.github.io/blog/2016/11/01/c++11_basic/">C++标准转换运算符reinterpret_cast</a></li>
<li><a href="http://www.pandademo.com/2016/09/arena-rocksdb-source-dissect-0/">Arena内存管理优化-RocksDB源码剖析(0)</a></li>
</ul>

			</div>

			<div class="tags">
				
					
						<ul class="flat">
							
							<li><a href="/tags/leveldb">LevelDB</a></li>
							
						</ul>
					
				
			</div></div>
	</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div>2022  © Hawkingrei |  <a href="https://github.com/knadh/hugo-ink">Ink</a> theme on <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>

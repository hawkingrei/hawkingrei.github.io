<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hawkingrei</title>
    <link>http://hawkingrei.com/posts/</link>
    <description>Recent content in Posts on Hawkingrei</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>© Hawkingrei</copyright>
    <lastBuildDate>Sat, 09 Dec 2017 14:00:00 +0000</lastBuildDate><atom:link href="http://hawkingrei.com/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>LevelDB代码阅读：Arena</title>
      <link>http://hawkingrei.com/posts/articles/area_in_leveldb/2017-12-09-arena-in-leveldb/</link>
      <pubDate>Sat, 09 Dec 2017 14:00:00 +0000</pubDate>
      
      <guid>http://hawkingrei.com/posts/articles/area_in_leveldb/2017-12-09-arena-in-leveldb/</guid>
      <description>Arena源代码分析 首先我们来看定义
class Arena {  public:  Arena();  ~Arena();   // Return a pointer to a newly allocated memory block of &amp;#34;bytes&amp;#34; bytes.  char* Allocate(size_t bytes);   // Allocate memory with the normal alignment guarantees provided by malloc  char* AllocateAligned(size_t bytes);   // Returns an estimate of the total memory usage of data allocated  // by the arena.  size_t MemoryUsage() const {  return reinterpret_cast&amp;lt;uintptr_t&amp;gt;(memory_usage_.</description>
    </item>
    
    <item>
      <title>LevelDB代码阅读：Varint</title>
      <link>http://hawkingrei.com/posts/articles/varint_in_leveldb/2017-11-15-varint-in-leveldb/</link>
      <pubDate>Wed, 15 Nov 2017 14:00:00 +0000</pubDate>
      
      <guid>http://hawkingrei.com/posts/articles/varint_in_leveldb/2017-11-15-varint-in-leveldb/</guid>
      <description>C++一直是我想要学习的编程语言之一，但是拖延症，使我始终都没有学个明白。所以借LevelDb代码阅读之际，复习一下，随带学习一下KV数据库
Varint介绍 Varint是Leveldb中的一种表示数字的方法，他用一个或多个字节表示一个数字，值越少的数字，所占用的字节数越少。比如对于int32类型的数字，一般需要4个byte来表示。但是采用Varint，对于很小的int32类型的数字，则可以用1个byte来表示。当然凡事都有好的也有不好的一面，采用Varint表示法，大的数字则需要5个byte来表示。从统计的角度来说，一般不会所有的消息中的数字都是大数，因此大多数情况下，采用Varint 后，可以用更少的字节数来表示数字信息。
Varint每个byte的最高位bit有特殊含义，如果该位为1，表示后续的byte也是该数字的一部分，如果该位为0，则结束。其他的7 个bit都用来表示数字。因此小于128的数字都可以用一个byte表示。大于 128的数字，比如300，会用两个字节来表示：1010 1100 0000 0010。
Varint源代码分析 Varint的源代码位于LevelDB的util/coding.cc，util/coding.h内
我们来看一下util/coding.cc, 正常情况下，int需要32位，varint用一个字节的最高为做标识位，所以，一个字节只能存储7位，如果整数特别大，可能需要5个字节才能存放{5 * 8 - 5(标识位) &amp;gt; 32}，下面的if语句有5个分支，正好对应varint占用1到5个字节的情况。
char* EncodeVarint32(char* dst, uint32_t v) {  // Operate on characters as unsigneds  unsigned char* ptr = reinterpret_cast&amp;lt;unsigned char*&amp;gt;(dst);  static const int B = 128;  if (v &amp;lt; (1&amp;lt;&amp;lt;7)) {  *(ptr++) = v;  } else if (v &amp;lt; (1&amp;lt;&amp;lt;14)) {  *(ptr++) = v | B;  *(ptr++) = v&amp;gt;&amp;gt;7;  } else if (v &amp;lt; (1&amp;lt;&amp;lt;21)) {  *(ptr++) = v | B;  *(ptr++) = (v&amp;gt;&amp;gt;7) | B;  *(ptr++) = v&amp;gt;&amp;gt;14;  } else if (v &amp;lt; (1&amp;lt;&amp;lt;28)) {  *(ptr++) = v | B;  *(ptr++) = (v&amp;gt;&amp;gt;7) | B;  *(ptr++) = (v&amp;gt;&amp;gt;14) | B;  *(ptr++) = v&amp;gt;&amp;gt;21;  } else {  *(ptr++) = v | B;  *(ptr++) = (v&amp;gt;&amp;gt;7) | B;  *(ptr++) = (v&amp;gt;&amp;gt;14) | B;  *(ptr++) = (v&amp;gt;&amp;gt;21) | B;  *(ptr++) = v&amp;gt;&amp;gt;28;  }  return reinterpret_cast&amp;lt;char*&amp;gt;(ptr); } 看了编码，我们再来看看解码util/coding.</description>
    </item>
    
    <item>
      <title>优雅の使用sync.WaitGroup</title>
      <link>http://hawkingrei.com/posts/articles/gracefully_use_waitgroup/2017-08-26-gracefully-use-waitgroup/</link>
      <pubDate>Sat, 26 Aug 2017 14:00:00 +0000</pubDate>
      
      <guid>http://hawkingrei.com/posts/articles/gracefully_use_waitgroup/2017-08-26-gracefully-use-waitgroup/</guid>
      <description>Background 自从上次参加2017 GopherChina被安利了NSQ后，阅读了NSQ的源代码,从中学到了不少代码技巧。于是乎，我就把这些代码技巧运用到了veda上，提高了代码质量。
WaitGroup介绍 WaitGroup用来等待一群goroutine结束，主Goroutine调用Add来设置有多少goroutines需要去等待。然后各个goroutines开始运行，当结束时，调用Done。同时，可以使用Wait来堵塞程序，直到全部Goroutines已经结束。下面是一个WaitGroup的小例子。
var wg sync.WaitGroup var urls = []string{  &amp;#34;http://www.golang.org/&amp;#34;,  &amp;#34;http://www.google.com/&amp;#34;,  &amp;#34;http://www.somestupidname.com/&amp;#34;, } for _, url := range urls {  // Increment the WaitGroup counter.  wg.Add(1)  // Launch a goroutine to fetch the URL.  go func(url string) {  // Decrement the counter when the goroutine completes.  defer wg.Done()  // Fetch the URL.  http.Get(url)  }(url) } // Wait for all HTTP fetches to complete.</description>
    </item>
    
    <item>
      <title>Linux系统编程笔记：Linux中的fork</title>
      <link>http://hawkingrei.com/posts/articles/linux_fork/2017-08-07-linux-fork/</link>
      <pubDate>Tue, 08 Aug 2017 10:00:00 +0000</pubDate>
      
      <guid>http://hawkingrei.com/posts/articles/linux_fork/2017-08-07-linux-fork/</guid>
      <description>“fork是一种创建自身进程副本的操作。 ”
 Background 最近正在阅读Twemproxy的源代码，从中发现涉及到大量《操作系统原理》和Linux系统编程的知识，由此我这些知识记录下来，做一个系列的笔记。
概论 在多任务操作系统中，运行中的程序需要一种方法来创建新进程，例如运行其他程序。Fork及其变种在类Unix系统中通常是这样做的唯一方式。如果进程需要启动另一个程序的可执行文件，它需要先Fork来创建一个自身的副本。然后由该副本即“子进程”调用exec系统调用，用其他程序覆盖自身：停止执行自己之前的程序并执行其他程序。
正文 进程复制 Fork操作会为子进程创建一个单独的定址空间。子进程拥有父进程所有内存段的精确副本，其中包括：进程上下文、进程堆栈、内存信息、打开的文件描述符、信号控制设置、进程优先级、进程组号、当前工作目录、根目录、资源限制、控制终端等。
当一个进程调用fork时，它被认为是父进程，新创建的进程是它的孩子（子进程）。在fork之后，两个进程还运行着相同的程序，都像是调用了该系统调用一般恢复执行。然后它们可以检查调用的返回值确定其状态：是父进程还是子进程，以及据此行事。
子进程与父进程的区别在于：
  父进程设置的锁，子进程不继承（因为如果是排它锁，被继承的话，矛盾了）。
  各自的进程ID和父进程ID不同,且与存在的进程PID都不同。
  子进程的未决告警被清除。
  子进程的未决信号集设置为空集。
  子进程不会从父进程继承dnotify(directory change notifications)。
  在子进程中的 resource utilizations (getrusage)和CPU time counters (times)会被归零。
  子进程不能从父进程继承计时器(setitimer, alarm, timer_create)。
  子进程不能从父进程继承异步I/0操作（aio_write,aio_read）,也不能从父进程继承asynchronous I/O contexts.(io_setup)。
  上面列出是在POSIX.1-2001下的不同点,下面是linux系统特用的不通点。
  子进程不能继承由ioperm设置的I/O 端口访问权限，子进程必须使用ioperm来开启端口访问权限。
  子进程的中断信号是SIGCHLD（clone）。
  Memory mappings 是被madvise设置的话，MADV_DONTFORK标识不会继承给子进程的
  默认的timer slack值由父进程中的当前timer slack值来设置。 （可以看一下prctl中的PR_SET_TIMERSLACK的描述）</description>
    </item>
    
    <item>
      <title>start.sh</title>
      <link>http://hawkingrei.com/posts/articles/start_sh/2017-06-26-start-sh/</link>
      <pubDate>Sun, 25 Jun 2017 10:00:00 +0000</pubDate>
      
      <guid>http://hawkingrei.com/posts/articles/start_sh/2017-06-26-start-sh/</guid>
      <description>“Yeah It&amp;rsquo;s on. ”
 终于在一次次的尝试后，终于令我满意的方案，去开启我的blog之旅。
我最早的blog是高中的时候挂在blogbus上的，不过那都是我从csdn上摘抄来的东西，虽然行为有些幼稚，不过可以看出当时的我对计算机还是无比热爱的。不过最后我并没有读上自己喜欢的计算机专业，反而读了药学，浪费了四年提升计算机水平的机会，还不慎在计算机的道路上走偏。
大四的时候毅然把原本所学的专业彻底放弃，开始成为了程序员，从一开始的前端工程师，到现在的后端工程师。越发感觉到自己在计算机的不足，因此我更加需要一个blog，可以记录下自己的学习过程和感谢，加深自己的记忆。
为什么选用Jekyll 高度可定制化，又不会像Wordpress做的太复杂，同时我也不太想学PHP 。同时wordpress时不时就会爆出漏洞，很是麻烦。
相比之下，Jekyll就方便很多了，通过书写markdown就可以写博文，可以版本控制，发布只需要把生成的静态文件上传，也没有什么安全问题。
定位 对于我这个喜欢显摆的程序员，之后我在这个blog中，记录我各种看到的新奇技术，来源不是其他blog的摘抄，而是从阅读各类paper，遇到的各类问题中，收获到的经验和知识。还有我各式各样的造轮子，供大家调戏。</description>
    </item>
    
  </channel>
</rss>
